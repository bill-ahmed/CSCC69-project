            +--------------------+
            | CSCC69             |
            | PROJECT 1: THREADS |
            | DESIGN DOCUMENT    |
            +--------------------+
   
---- GROUP ----

>> Fill in the names and email addresses of your group members.

Tanner Bergeron tanner.bergeron@mail.utoronto.ca
Tanaan Karunakaran tanaan.karunakaran@mail.utoronto.ca
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

                 ALARM CLOCK
                 ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

    /* Required a notion of a thread being asleep since blocked is
    going to be reserved for locks. */
    enum thread_status
    {
        /* New thread state */
        THREAD_SLEEPING,    /* Waiting on timer to wake it up */ 
    };

    /* If threads can sleep, we need to know for how long. Member only
    accessed if thread is running and going to sleep */
    struct thread
    {
        /* New struct member */
        int64_t wakeup_time;     /* When to wake up this thread from sleep */
    }

    /* Required to keep track of which threads are currently sleeping.
    Sorted by thread->wakeup_time ASC for fast timer checks */
    struct list sleeped_threads_list;

---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

    timer_sleep calls thread_sleep with the time it should wake
    up at.

    thread_sleep fills in the thread information, sets it's status
    to sleeping, adds it to a sleeping thread list, and finally
    calls the scheduler to switch threads. All of these actions
    must be atomic, so inturrupts are disabled for the duration
    of these calls inside thread_sleep.

    Once the stack is restored and it wakes up, it continues and
    returns from timer_sleep as it should.

    When a timer inturrupt occurs, it ticks and then it checks
    if any sleeping threads should be woken up. Any threads that
    have waited long enough are dequeued from the sleeping list,
    made their status set to ready, and added to the ready list.

    This means when the timer inturrupt finishes and yields, a
    newly awoken thread now has the possibility of being chosen
    and run.

>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

    The list of sleeping threads is sorted by wakeup_time which
    means if we know the current time, we can look at the first
    thread in the list and if it is not ready to be awoken, we
    also know none of the others are either. This means sleeping
    a large number of threads causes no penalty to timer inturrupts.

---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

    A thread is only able to put itself to sleep, therefore until
    it runs code to actually change the state of the thread and
    add it to the sleeping list, and schedule, all other operations
    need not be atomic. The few that are, are surrounded by inturrupt
    disable and enable.

>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

    Atomic section is minimally wrapped by inturrupt disable/restore.

---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

    We needed a way to tell the scheduler not to schedule a sleeping
    thread, and a way to wake it up efficiently after an amount of time.
    Busy waiting will not do.

    We wanted to write a minimal amount of code because adding something
    overly complex just introduces bugs. Having a sorted list of sleeping
    threads was the most efficient because of what is mentioned in A3.
    Each timer inturrupt we need to check if we should wake up any sleeping
    threads. That iteration through the list of potentially hundreds of
    threads is costly and sorting by wake up time allows us to often only
    need to check the first thread in the list to decide whether to continue.

    This was an efficient implementaiton with not much code added to the
    base handout.

             PRIORITY SCHEDULING
             ===================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

>> B2: Explain the data structure used to track priority donation.
>> Use ASCII art to diagram a nested donation.  (Alternately, submit a
>> .png file.)

---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?

>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?

>> B5: Describe the sequence of events when lock_release() is called
>> on a lock that a higher-priority thread is waiting for.

---- SYNCHRONIZATION ----

>> B6: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?

---- RATIONALE ----

>> B7: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

              ADVANCED SCHEDULER
              ==================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Suppose threads A, B, and C have nice values 0, 1, and 2.  Each
>> has a recent_cpu value of 0.  Fill in the table below showing the
>> scheduling decision and the priority and recent_cpu values for each
>> thread after each given number of timer ticks:

timer  recent_cpu    priority   thread
ticks   A   B   C   A   B   C   to run
-----  --  --  --  --  --  --   ------
 0
 4
 8
12
16
20
24
28
32
36

>> C3: Did any ambiguities in the scheduler specification make values
>> in the table uncertain?  If so, what rule did you use to resolve
>> them?  Does this match the behavior of your scheduler?

>> C4: How is the way you divided the cost of scheduling between code
>> inside and outside interrupt context likely to affect performance?

---- RATIONALE ----

>> C5: Briefly critique your design, pointing out advantages and
>> disadvantages in your design choices.  If you were to have extra
>> time to work on this part of the project, how might you choose to
>> refine or improve your design?

>> C6: The assignment explains arithmetic for fixed-point math in
>> detail, but it leaves it open to you to implement it.  Why did you
>> decide to implement it the way you did?  If you created an
>> abstraction layer for fixed-point math, that is, an abstract data
>> type and/or a set of functions or macros to manipulate fixed-point
>> numbers, why did you do so?  If not, why not?

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
